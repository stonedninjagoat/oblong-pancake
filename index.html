<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MIDI Info Extractor</title>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #output { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>MIDI to CSV Tool</h1>
  <p>Ensure MIDI files have only one track, no percussion, and one tempo.</p>
  <input type="file" id="midiInput" accept=".mid,.midi" multiple />
  <button onclick="processFiles()">Process MIDI Files</button>
  <div id="output"></div>

  <script>
    async function processFiles() {
      const files = document.getElementById('midiInput').files;
      for (const file of files) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const midi = new Midi(arrayBuffer);
          const filename = file.name.replace(/\.[^/.]+$/, "");

          const cleanedMidi = uploadCheck(midi, filename);
          const { tempo } = getTempos(cleanedMidi, filename);
          const noteDurations = getNoteDurations(cleanedMidi, filename);
          const convertedDurations = convertNoteDurations(cleanedMidi, filename);
          const midiNumbers = getMIDInumber(cleanedMidi, filename);
          const convertedMIDIs = convertMIDInumber(midiNumbers, filename);
          const timeSigs = getTimeSigs(cleanedMidi, filename);
          const groupedData = organizeMeasures(cleanedMidi, convertedDurations, timeSigs, filename);

          const csvLines = [];
          csvLines.push(`tempo,${tempo}`);
          csvLines.push(`convertedMIDINumbers,"${JSON.stringify(convertedMIDIs)}"`);
          csvLines.push(`groupedData,"${JSON.stringify(groupedData)}"`);

          const csvContent = csvLines.join("\n");

          document.getElementById("output").textContent += `\n===== ${filename}.csv =====\n${csvContent}\n`;

          downloadCSV(filename, csvContent);
        } catch (err) {
          console.error(`Error processing ${file.name}:`, err.message);
        }
      }
    }

    function downloadCSV(filename, content) {
      const blob = new Blob([content], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename + ".csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function uploadCheck(midi, filename) {
      if (midi.tracks.length !== 1) {
        throw new Error(`${filename}: contains ${midi.tracks.length} tracks (only 1 allowed).`);
      }
      if (midi.tracks[0].notes.some(note => note.midi >= 35 && note.midi <= 81 && note.channel === 9)) {
        throw new Error(`${filename}: contains percussive notes (channel 10).`);
      }
      if (midi.header.tempos.length !== 1) {
        throw new Error(`${filename}: contains ${midi.header.tempos.length} tempos (only 1 allowed).`);
      }
      return midi;
    }

    function getTempos(midi, filename) {
      const tempo = midi.header.tempos[0].bpm;
      return { tempo };
    }

    function getNoteDurations(midi, filename) {
      const notes = midi.tracks[0].notes;
      return notes.map(note => note.duration);
    }

    function convertNoteDurations(midi, filename) {
      const ppq = midi.header.ppq;
      const notes = midi.tracks[0].notes;
      return notes.map(note => {
        const ticks = note.durationTicks;
        const quarter = ppq;
        const eighth = ppq / 2;
        const sixteenth = ppq / 4;
        const half = ppq * 2;
        const whole = ppq * 4;

        const closest = (val, arr) => arr.reduce((a, b) =>
          Math.abs(a - val) < Math.abs(b - val) ? a : b
        );

        const types = {
          [whole]: "1/1",
          [half * 1.5]: "dotted 1/2",
          [half]: "1/2",
          [quarter * 1.5]: "dotted 1/4",
          [quarter]: "1/4",
          [eighth * 1.5]: "dotted 1/8",
          [eighth]: "1/8",
          [sixteenth * 1.5]: "dotted 1/16",
          [sixteenth]: "1/16"
        };

        const best = closest(ticks, Object.keys(types).map(Number));
        return types[best] || `${ticks} ticks`;
      });
    }

    function getMIDInumber(midi, filename) {
      return midi.tracks[0].notes.map(note => note.midi);
    }

    function convertMIDInumber(midiNumbers, filename) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      return midiNumbers.map(num => {
        const octave = Math.floor(num / 12) - 1;
        const note = noteNames[num % 12];
        return `${note}${octave}`;
      });
    }

    function getTimeSigs(midi, filename) {
      return midi.header.timeSignatures.map(sig => `${sig.timeSignature[0]}/${sig.timeSignature[1]}`);
    }

    function organizeMeasures(midi, convertedNoteDurations, timeSigs, filename) {
      const track = midi.tracks[0];
      const notes = track.notes;
      const ppq = midi.header.ppq;

      const measureGroups = {};
      notes.forEach((note, i) => {
        const ticks = note.ticks;
        const timeSigEvent = midi.header.timeSignatures.find(ts => ts.ticks <= ticks) || { timeSignature: [4, 4] };
        const measureLength = (ppq * 4 * timeSigEvent.timeSignature[0]) / timeSigEvent.timeSignature[1];
        const measureNumber = Math.floor(ticks / measureLength);

        if (!measureGroups[measureNumber]) {
          measureGroups[measureNumber] = [];
        }
        measureGroups[measureNumber].push(convertedNoteDurations[i]);
      });

      return measureGroups;
    }
  </script>
</body>
</html>
