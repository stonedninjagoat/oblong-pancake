// Get BPM robustly
const tempos = Array.isArray(midi.header.tempos) ? midi.header.tempos : [];
let bpm = 120;
let bpmSource = "default (120)";
if (tempos.length === 1 && typeof tempos[0].bpm === "number") {
  bpm = tempos[0].bpm;
  bpmSource = bpm.toFixed(2);
} else if (tempos.length > 1 && typeof tempos[0].bpm === "number") {
  bpm = tempos[0].bpm;
  bpmSource = `multiple detected, using first (${bpm.toFixed(2)})`;
}

// Quarter note length in seconds (based on BPM)
const quarterNoteLength = bpm > 0 ? 60 / bpm : 0.5; // fallback quarter length

// Modified durationToNotation to guard against invalid input
function durationToNotation(duration, quarterLength) {
  if (!quarterLength || quarterLength <= 0 || typeof duration !== "number" || duration <= 0) return duration.toFixed ? duration.toFixed(3) : String(duration);

  const ratio = duration / quarterLength;
  const roundRatio = Math.round(ratio * 8) / 8; // round to nearest 1/8

  const noteMap = [
    { name: "whole (4/4)", value: 4 },
    { name: "dotted half (3/4)", value: 3 },
    { name: "half (2/4)", value: 2 },
    { name: "dotted quarter (1.5 1/4)", value: 1.5 },
    { name: "quarter (1/4)", value: 1 },
    { name: "dotted eighth (0.75 1/8)", value: 0.75 },
    { name: "eighth (1/8)", value: 0.5 },
    { name: "sixteenth (1/16)", value: 0.25 },
  ];

  let closest = null;
  let minDiff = Infinity;
  for (const note of noteMap) {
    const diff = Math.abs(note.value - roundRatio);
    if (diff < minDiff) {
      minDiff = diff;
      closest = note;
    }
  }

  if (minDiff < 0.1) {
    return `${closest.name} (~${roundRatio.toFixed(2)})`;
  }

  return ratio.toFixed(3);
}
